#!/usr/bin/python3
import rclpy
from  rclpy.node import Node
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
import sys
import scan_echo
from move_robot import stop_mov, move_metre, move_degre

# Ros Node process:
def main():
    # Initialize ROS and a ROS node
    rclpy.init(args=sys.argv)
    node= Node( 'basic_move' )

    # Initialize our control:
    control= StraightCtrl()
    control.initializeRosNode( node )

    # infinite Loop:
    rclpy.spin( node )

    # clean end
    node.destroy_node()
    rclpy.shutdown()

# Ros Node Class:
class StraightCtrl :
    def initializeRosNode(self, rosNode ):
        # Get logger from the node:
        self._logger= rosNode.get_logger()
        self.obstacle_right=False
        self.obstacle_left=False
        self.no_scan=True
        # Initialize publisher:
        self._pubVelocity= rosNode.create_publisher(
            Twist, '/multi/cmd_nav', 10
        )

        # Initialize scan callback:
        self._subToScan= rosNode.create_subscription(
            LaserScan, '/scan',
            self.scan_callback, 10
        )

        # Initialize control callback:
        self._timForCtrl= rosNode.create_timer(
            0.05, self.control_callback
        )

    def scan_callback(self, scanMsg ):
        self._logger.info( '> get scan' )
        self.process_scan_data(scanMsg)


    def control_callback(self):
        self._logger.info( '< define control' )
        velocity=Twist()
        velocity.angular.z = 0.5 #rad/s
        if self.no_scan:
            print("no scan")
            velocity.linear.x = 0.0 #m/s
            velocity.angular.z = 0.0 #rad/s
            self._pubVelocity.publish(velocity)
        elif self.obstacle_right and not self.obstacle_left:
            print("obstacle right")
            #move_degre(-5)
            velocity.linear.x = 0.0 #m/s
            velocity.angular.z = 0.5 #rad/s
            self._pubVelocity.publish(velocity)
        elif self.obstacle_left and not self.obstacle_right:
            print("obstacle left")
            #move_degre(5)
            velocity.linear.x = 0.0 #m/s
            velocity.angular.z = -0.5 #rad/s
            self._pubVelocity.publish(velocity)
        elif self.obstacle_right and self.obstacle_left:
            print("obstacle both directions")
            #move_degre(5)
            velocity.linear.x = 0.0 #m/s
            self._pubVelocity.publish(velocity)
        else:
            #move_metre(0.10)            
            velocity.linear.x = 0.4 #m/s
            velocity.angular.z = 0.0#rad/s
            self._pubVelocity.publish(velocity)
            print("no obstacles")
        print("done")
       

    def process_scan_data(self,scanMsg):
        self.obstacle_right=False
        self.obstacle_left=False
        if scanMsg is not None : 
            self.no_scan=False
            angle= scanMsg.angle_min
            for aDistance in scanMsg.ranges :
                if 0.1 < aDistance and aDistance < 0.6 :
                    if angle <0 and angle >-1:
                        self.obstacle_right=True
                    if angle >0 and angle <1:
                        self.obstacle_left=True
                angle+= scanMsg.angle_increment
        else : 
            self.no_scan=True
            print("Scan not found, exit")
        
# Go:
if __name__ == '__main__' :
    main()