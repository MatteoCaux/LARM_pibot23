#!/usr/bin/python3
import rclpy
from  rclpy.node import Node
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
import sys
import scan_echo
from move_robot import stop_mov, move_metre, move_degre
from math import sin

#positive :gauche:left
# Ros Node process:
def main():
    # Initialize ROS and a ROS node
    rclpy.init(args=sys.argv)
    node= Node( 'basic_move' )

    # Initialize our control:
    control= StraightCtrl()
    control.initializeRosNode( node )

    # infinite Loop:
    rclpy.spin( node )

    # clean end
    node.destroy_node()
    rclpy.shutdown()

# Ros Node Class:
class StraightCtrl :
    def initializeRosNode(self, rosNode ):                                            #initialization
        # Get logger from the node:
        self._logger= rosNode.get_logger()
        self.obstacle_right_close=False
        self.obstacle_left_close=False
        self.obstacle_right_far=False
        self.obstacle_left_far=False
        self.obstacle_full_left_far=False
        self.obstacle_full_right_far=False
        self.no_scan=True
        self.step=0
        self.previous_z=0.5
        self.previous_x=0.15
        self.previous_message=""
        # Initialize publisher:
        self._pubVelocity= rosNode.create_publisher(
            Twist, '/multi/cmd_nav', 10
        )

        # Initialize scan callback:
        self._subToScan= rosNode.create_subscription(
            LaserScan, '/scan',
            self.scan_callback, 10
        )

        # Initialize control callback:
        self._timForCtrl= rosNode.create_timer(
            0.05, self.control_callback
        )

    def scan_callback(self, scanMsg ):
        #self._logger.info( '> get scan' )
        self.process_scan_data(scanMsg)


    def control_callback(self):
        #self._logger.info( '< define control' )
        self.states=[]
        velocity=Twist()
        velocity.angular.z = self.previous_z #rad/s
        base_angular_speed=0.7                                                         #rotation speed
        message=""

        #=================================#
        # First case : nothing is scanned #
        #=================================#
        if self.no_scan:                                                               #if nothing is scanned, the robot stop
            print("no scan")
            self.step = 0
            velocity.linear.x = 0.0 #m/s
            velocity.angular.z = 0.0 #rad/s
            self._pubVelocity.publish(velocity)

        #======================================#
        # Second case : something is too close #
        #======================================#
        elif self.totalmindistance<0.15:                                                #if an object is too close, the robot can only rotate on itself
            message+="object to close, turning around\n"
            velocity.linear.x = 0.0 #m/s
            self._pubVelocity.publish(velocity)
 
        #=================================#
        # Third case : something is close #
        #=================================#
        elif self.obstacle_right_close or self.obstacle_left_close:                     #something is close
            #We look at the situation (where are the obstacles) and we choose where to move

            # 1) something is close both on the right and on the left
            if self.obstacle_right_close and self.obstacle_left_close:                  
                message+="state3:close obstacle both directions\n"
                self.step = 0

                #Â is there an obstacle far ?
                if self.obstacle_full_left_far and not self.obstacle_full_right_far:    #also there is something far on the right but not on the left
                    message+="choosed to go right\n"                                    #so the robot go to the right
                    velocity.angular.z = -base_angular_speed #rad/s 
                if self.obstacle_full_right_far and not self.obstacle_full_left_far:    #also there is something far on the left but not on the right
                    message+="choosed to go left\n"                                     #so the robot go to the left
                    velocity.angular.z=base_angular_speed

                #We adapt our speed to the current one
                if velocity.angular.z==0:                                               #if its the first turn and there is not one far side triggered, the robot go to the left
                    velocity.angular.z=base_angular_speed                  
                if self.previous_x>0.5:                                                 #if the robot was moving fast, it slows hardly
                    velocity.linear.x=self.previous_x -0.05
                elif self.previous_x>0.0:                                               #if the robot was moving slow, its slow softly
                    velocity.linear.x=self.previous_x -0.02
                else:                                                                   #if the robot was not moving, it continue
                    velocity.linear.x=0.0 
                
            # 2) something is close on the right but not on the left    
            elif self.obstacle_right_close and not self.obstacle_left_close:
                message+="state1:close obstacle right\n"
                self.step = 0

                #We adapt our speed to the current one
                if self.previous_x>0.5:
                    velocity.linear.x=self.previous_x -0.05
                elif self.previous_x>0.0:
                    velocity.linear.x=self.previous_x -0.02
                else:
                    velocity.linear.x = 0.0 #m/s

                #is there something far on the left ?    
                if not self.obstacle_full_left_far:                                      #if not the robot turn to the left
                    velocity.angular.z = base_angular_speed #rad/s
                if velocity.angular.z==0:
                    velocity.angular.z=base_angular_speed

            # 3) something is close on the left but not on the right        
            elif self.obstacle_left_close and not self.obstacle_right_close:
                message+="state2:close obstacle left\n"
                self.step = 0  

                #We adapt our speed to the current one              
                if self.previous_x>0.5:
                    velocity.linear.x=self.previous_x -0.05
                elif self.previous_x>0.0:
                    velocity.linear.x=self.previous_x -0.02
                else:
                    velocity.linear.x = 0.0 #m/s

                #is there something far on the right ?     
                if not self.obstacle_full_right_far:                                     #if not the robot turn to the right
                    velocity.angular.z = -base_angular_speed #rad/s
                if velocity.angular.z==0:
                    velocity.angular.z=base_angular_speed

            if velocity.linear.x<0.0:velocity.linear.x=0.0                               #avoiding errors

            #previous values
            self.previous_z=velocity.angular.z
            self.previous_x=velocity.linear.x

            #publishing
            self._pubVelocity.publish(velocity)

        #================================#
        # Fourth case : something is far #
        #================================#
        elif self.obstacle_right_far or self.obstacle_left_far:
            #We look at the situation (where are the obstacles) and we choose where to move

            # 1) something is far on the right but not on the left  
            if self.obstacle_right_far and not self.obstacle_left_far:
                message+="state4:far obstacle right\n"
                self.step =0

                #the robot goes to the linear speed of 0.2 smoothly
                if self.previous_x>0.21:
                    velocity.linear.x=self.previous_x -0.02
                elif self.previous_x<0.19:
                    velocity.linear.x=self.previous_x +0.02
                else:
                    velocity.linear.x=0.2

                #the angle is adapted to the distance (the closer the obstacle is, the greater is the angle)
                velocity.angular.z = -0.83*self.mindistance+1.45 #rad/s                    the robot goes to the left
  
            # 2) something is far on the left but not on the right  
            elif self.obstacle_left_far and not self.obstacle_right_far:
                message+="state5:far obstacle left\n"
                self.step=0

                #the robot goes to the linear speed of 0.2 smoothly
                if self.previous_x>0.21:
                    velocity.linear.x=self.previous_x -0.02
                elif self.previous_x<0.19:
                    velocity.linear.x=self.previous_x +0.02
                else:
                    velocity.linear.x=0.2

                #the angle is adapted to the distance (the closer the obstacle is, the greater is the angle)
                velocity.angular.z = -(-0.83*self.mindistance+1.45) #rad/s                   the robot goes to the right

            # 3) something is far both on the right and the left
            elif self.obstacle_right_far and self.obstacle_left_far:
                message+="state6:far obstacle both directions\n"
                self.step = 0

                #there is something at 90 degres on the left and not on the right
                if self.obstacle_full_left_far and not self.obstacle_full_right_far:
                    velocity.angular.z = -base_angular_speed #rad/s                           the robot goes to the right
                
                #there is something at 90 degres on the right and not on the left
                if self.obstacle_full_right_far and not self.obstacle_full_left_far:
                    velocity.angular.z=base_angular_speed #rad/s                               the robot goes to the left

                #the robot goes to the linear speed of 0.15 smoothly
                if self.previous_x>0.3:
                     velocity.linear.x=self.previous_x -0.05
                elif self.previous_x>0.17:
                    velocity.linear.x=self.previous_x -0.03
                elif self.previous_x<0.13:
                    velocity.linear.x=self.previous_x +0.03
                else:
                    velocity.linear.x=0.15

            #previous values
            self.previous_z=velocity.angular.z
            self.previous_x=velocity.linear.x

            #publishing
            self._pubVelocity.publish(velocity)


        #===================================#
        # Fifth case : no obstacle in front #
        #===================================#
        else:
            #the robot goes forward

            velocity.angular.z = 0.0#rad/s
            self.forward_smooth_accel()
            message+="state 0:no obstacles\n"
            self.step += 1
        
        
        #=============================#
        # Print the current situation #
        #=============================#
        #printing if there are obstacles and where and the current linear and rotative speeds
        message+=str(self.obstacle_left_far)+","+str(self.obstacle_right_far)+"\n"+str(self.obstacle_left_close)+","+str(self.obstacle_right_close)+"\n"+str(self.obstacle_full_left_far)+","+str(self.obstacle_full_right_far)+"\n"+"speed:"+str(self.previous_x)+"    rotation:"+str(self.previous_z)

        #the message is printed only if it is different from the previous one
        if True: # self.previous_message!=message:
            print("#----------------#")
            print(message)
            print("|----------------|")
        self.previous_message=message


    #================================================================#
    # Definition of the position of the obstacle from the LIDAR data #
    #================================================================#
    def process_scan_data(self,scanMsg):
        #Initialization
        self.obstacle_right_close=False
        self.obstacle_left_close=False
        self.obstacle_right_far=False
        self.obstacle_left_far=False
        self.obstacle_full_left_far=False
        self.obstacle_full_right_far=False
        self.totalmindistance=10
        self.maxdistance=0
        self.mindistance=10

        # The robot looks in a 40cm tunnel in front of him
        scan_tunnel_d=0.40

        if scanMsg is not None : 
            self.no_scan=False
            angle= scanMsg.angle_min
            for aDistance in scanMsg.ranges :

                #for each distance received we look if the obstacle is in the tunnel in front the robot and if so, where it is (right, left, far, close)    
                if 0.1 < aDistance:
                    if aDistance < 1.1 :
                        if self.totalmindistance>aDistance:self.totalmindistance=aDistance
                        if aDistance<0.35:
                            if angle <0 and angle >-1:
                                self.obstacle_right_close=True
                            if angle >0 and angle <1:
                                self.obstacle_left_close=True
                        else:
                            if angle <0 and angle >-1:
                                if scan_tunnel_d/(2*sin(-angle))>=aDistance:
                                    self.obstacle_right_far=True
                                    if self.maxdistance<aDistance: self.maxdistance=aDistance
                                    if self.mindistance>aDistance: self.mindistance=aDistance   
                            if angle >0 and angle <1:
                                if scan_tunnel_d/(2*sin(angle))>=aDistance:
                                    self.obstacle_left_far=True
                                    if self.maxdistance<aDistance: self.maxdistance=aDistance
                                    if self.mindistance>aDistance: self.mindistance=aDistance

                    #we also look if there are obstacles at 90 degres on each side of the robot
                    if aDistance<1.5:
                        if angle<-1.39 and angle >-1.55:
                            self.obstacle_full_right_far=True
                        if angle>1.39 and angle <1.55:
                            self.obstacle_full_left_far=True
                angle+= scanMsg.angle_increment
        else : 
            self.no_scan=True
            print("Scan not found, exit")

    #the robot accelerate smoothly
    def forward_smooth_accel(self):
        velocity_array=[0.1+i*0.02 for i in range(30)]
        if self.step >= len(velocity_array):
            self.step = len(velocity_array) - 1
        velocity=Twist()
        #print(self.step)
        velocity.linear.x = velocity_array[self.step] #m/s
        self.previous_z=velocity.angular.z
        self.previous_x=velocity.linear.x
        self._pubVelocity.publish(velocity)
    def find_state(self):
        return(0)
# Go:
if __name__ == '__main__' :
    main()